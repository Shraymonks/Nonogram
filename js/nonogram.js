// Generated by CoffeeScript 1.6.3
(function() {
  var controllers, directives, services;

  controllers = angular.module('nonogram.controllers', []);

  controllers.controller('BoardCtrl', function($scope, Nonogram, Draw) {
    var nonogram;
    nonogram = new Nonogram({
      size: 10
    });
    $scope.grid = nonogram.grid;
    $scope.rowNums = nonogram.rowNums;
    $scope.colNums = nonogram.colNums;
    $scope.handleClick = function(cell, colIndex, rowIndex, e) {
      e.preventDefault();
      switch (e.button) {
        case 0:
          switch (cell.state) {
            case 'on':
              Draw.state = 'on-blank';
              cell.state = 'blank';
              break;
            case 'blank':
              Draw.state = 'on';
              cell.state = 'on';
          }
          break;
        case 2:
          switch (cell.state) {
            case 'off':
              Draw.state = 'off-blank';
              cell.state = 'blank';
              break;
            case 'blank':
              Draw.state = 'off';
              cell.state = 'off';
          }
      }
      Draw.startPosition = {
        x: colIndex,
        y: rowIndex
      };
      return nonogram.checkRowNums(rowIndex);
    };
    $scope.handleDrag = function(cell, colIndex, rowIndex) {
      var col, draw, row, _i, _j, _ref, _ref1;
      draw = function(cell) {
        switch (Draw.state) {
          case 'on':
            if (cell.state !== 'off') {
              return cell.state = 'on';
            }
            break;
          case 'off':
            if (cell.state !== 'on') {
              return cell.state = 'off';
            }
            break;
          case 'off-blank':
            if (cell.state === 'off') {
              return cell.state = 'blank';
            }
            break;
          case 'on-blank':
            if (cell.state === 'on') {
              return cell.state = 'blank';
            }
        }
      };
      if ((Draw.startPosition.x != null) && (Draw.startPosition.y != null)) {
        if (!((Draw.direction != null) || (colIndex === Draw.startPosition.x && rowIndex === Draw.startPosition.y))) {
          if (colIndex !== Draw.startPosition.x) {
            Draw.direction = 'horizontal';
          } else if (rowIndex !== Draw.startPosition.y) {
            Draw.direction = 'vertical';
          }
        }
        switch (Draw.direction) {
          case 'horizontal':
            for (col = _i = _ref = Draw.startPosition.x; _ref <= colIndex ? _i <= colIndex : _i >= colIndex; col = _ref <= colIndex ? ++_i : --_i) {
              draw($scope.grid[Draw.startPosition.y][col]);
            }
            break;
          case 'vertical':
            for (row = _j = _ref1 = Draw.startPosition.y; _ref1 <= rowIndex ? _j <= rowIndex : _j >= rowIndex; row = _ref1 <= rowIndex ? ++_j : --_j) {
              draw($scope.grid[row][Draw.startPosition.x]);
            }
        }
        nonogram.checkRowNums(rowIndex);
      }
      return Draw.position = {
        x: colIndex,
        y: rowIndex
      };
    };
    $scope.endDrawMode = function() {
      Draw.direction = null;
      Draw.startPosition = {
        x: null,
        y: null
      };
      return Draw.state = false;
    };
    $scope.boardLeave = function() {
      $scope.endDrawMode();
      return Draw.position = {
        x: null,
        y: null
      };
    };
    $scope.preventDefault = function(e) {
      return e.preventDefault();
    };
    $scope.getCellClass = function(cell) {
      return {
        off: cell.state === 'off',
        on: cell.state === 'on'
      };
    };
    $scope.getColNumsClass = function(index) {
      return {
        highlight: index === Draw.position.x
      };
    };
    return $scope.getRowNumsClass = function(num, index) {
      return {
        complete: num.complete,
        highlight: index === Draw.position.y
      };
    };
  });

  directives = angular.module('nonogram.directives', []);

  directives.directive('disableContextMenu', function() {
    return function(scope, elem, attrs) {
      return elem.bind('contextmenu', function(e) {
        return e.preventDefault();
      });
    };
  });

  angular.module('nonogram', ['nonogram.controllers', 'nonogram.directives', 'nonogram.services']);

  services = angular.module('nonogram.services', []);

  services.factory('Nonogram', function() {
    var Nonogram, randomInt, shuffle;
    randomInt = function(min, max) {
      if (max == null) {
        max = min;
        min = 0;
      }
      return (Math.floor(Math.random() * (max - min + 1))) + min;
    };
    shuffle = function(list) {
      var i, rand, _i, _ref, _ref1;
      for (i = _i = _ref = list.length - 1; _ref <= 1 ? _i <= 1 : _i >= 1; i = _ref <= 1 ? ++_i : --_i) {
        rand = randomInt(i + 1);
        _ref1 = [list[rand], list[i]], list[i] = _ref1[0], list[rand] = _ref1[1];
      }
      return list;
    };
    Nonogram = (function() {
      function Nonogram(options) {
        var additionalCols, additionalRows, cell, col, colIndex, filledSquares, num, nums, row, rowIndex, _i, _j, _k, _l, _len, _len1, _m, _n, _o, _p, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
        this.size = options.size;
        this.numSquares = this.size * this.size;
        filledSquares = Math.round(this.numSquares * 0.5);
        this.squares = [];
        for (_i = 1; 1 <= filledSquares ? _i <= filledSquares : _i >= filledSquares; 1 <= filledSquares ? _i++ : _i--) {
          this.squares.push(true);
        }
        for (_j = 1, _ref = this.numSquares - filledSquares; 1 <= _ref ? _j <= _ref : _j >= _ref; 1 <= _ref ? _j++ : _j--) {
          this.squares.push(false);
        }
        this.squares = shuffle(this.squares);
        this.grid = [];
        for (rowIndex = _k = 0, _ref1 = this.size; 0 <= _ref1 ? _k < _ref1 : _k > _ref1; rowIndex = 0 <= _ref1 ? ++_k : --_k) {
          row = [];
          for (colIndex = _l = 0, _ref2 = this.size; 0 <= _ref2 ? _l < _ref2 : _l > _ref2; colIndex = 0 <= _ref2 ? ++_l : --_l) {
            row.push({
              filled: this.squares[rowIndex * this.size + colIndex],
              state: 'blank'
            });
          }
          this.grid.push(row);
        }
        additionalCols = 1;
        this.rowNums = [];
        _ref3 = this.grid;
        for (rowIndex = _m = 0, _len = _ref3.length; _m < _len; rowIndex = ++_m) {
          row = _ref3[rowIndex];
          nums = [];
          num = 0;
          for (colIndex = _n = 0, _len1 = row.length; _n < _len1; colIndex = ++_n) {
            cell = row[colIndex];
            if (cell.filled) {
              ++num;
              if (colIndex === this.size - 1) {
                nums.push({
                  complete: false,
                  value: num
                });
              }
            } else if (num !== 0) {
              nums.push({
                complete: false,
                value: num
              });
              num = 0;
            }
          }
          this.rowNums.push(nums);
          if (nums.length > additionalCols) {
            additionalCols = nums.length;
          }
        }
        additionalRows = 1;
        this.colNums = [];
        for (row = _o = 0, _ref4 = this.size; 0 <= _ref4 ? _o < _ref4 : _o > _ref4; row = 0 <= _ref4 ? ++_o : --_o) {
          nums = [];
          num = 0;
          for (col = _p = 0, _ref5 = this.size; 0 <= _ref5 ? _p < _ref5 : _p > _ref5; col = 0 <= _ref5 ? ++_p : --_p) {
            if (this.grid[col][row].filled) {
              ++num;
              if (col === this.size - 1) {
                nums.push({
                  complete: false,
                  value: num
                });
              }
            } else if (num !== 0) {
              nums.push({
                complete: false,
                value: num
              });
              num = 0;
            }
          }
          this.colNums.push(nums);
          if (nums.length > additionalRows) {
            additionalRows = nums.length;
          }
        }
      }

      Nonogram.prototype.checkRowNums = function(row) {
        var allNumsMatch, cell, currentSegments, index, num, segmentLength, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _n, _o, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _results;
        _ref = this.rowNums[row];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          num = _ref[_i];
          num.complete = false;
        }
        segmentLength = 0;
        currentSegments = [];
        _ref1 = this.grid[row];
        for (index = _j = 0, _len1 = _ref1.length; _j < _len1; index = ++_j) {
          cell = _ref1[index];
          switch (cell.state) {
            case 'on':
              ++segmentLength;
              if (index === this.grid[row].length - 1) {
                currentSegments.push(segmentLength);
              }
              break;
            case 'off':
            case 'blank':
              if (segmentLength > 0) {
                currentSegments.push(segmentLength);
              }
              segmentLength = 0;
          }
        }
        allNumsMatch = this.rowNums[row].every(function(num, index) {
          return num.value === currentSegments[index];
        });
        if (allNumsMatch) {
          _ref2 = this.rowNums[row];
          for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
            num = _ref2[_k];
            num.complete = true;
          }
          return;
        }
        segmentLength = 0;
        currentSegments = [];
        _ref3 = this.grid[row];
        for (index = _l = 0, _len3 = _ref3.length; _l < _len3; index = ++_l) {
          cell = _ref3[index];
          if (cell.state === 'on') {
            ++segmentLength;
          } else if (index === this.grid[row].length - 1 && cell.state !== 'blank') {
            currentSegments.push(segmentLength);
          } else if (cell.state === 'off') {
            if (segmentLength > 0 && currentSegments.length < this.rowNums[row].length - 1) {
              currentSegments.push(segmentLength);
            }
            segmentLength = 0;
          } else {
            break;
          }
        }
        _ref4 = this.rowNums[row];
        for (index = _m = 0, _len4 = _ref4.length; _m < _len4; index = ++_m) {
          num = _ref4[index];
          if (num.value === currentSegments[index]) {
            num.complete = true;
          } else {
            break;
          }
        }
        segmentLength = 0;
        currentSegments = [];
        _ref5 = this.grid[row];
        for (index = _n = _ref5.length - 1; _n >= 0; index = _n += -1) {
          cell = _ref5[index];
          if (cell.state === 'on') {
            ++segmentLength;
          } else if (index === 0 && cell.state !== 'blank') {
            currentSegments.push(segmentLength);
          } else if (cell.state === 'off') {
            if (segmentLength > 0 && currentSegments.length < this.rowNums[row].length - 1) {
              currentSegments.push(segmentLength);
            }
            segmentLength = 0;
          } else {
            break;
          }
        }
        _ref6 = this.rowNums[row];
        _results = [];
        for (index = _o = _ref6.length - 1; _o >= 0; index = _o += -1) {
          num = _ref6[index];
          if (num.value === currentSegments[this.rowNums[row].length - index - 1]) {
            _results.push(num.complete = true);
          } else {
            break;
          }
        }
        return _results;
      };

      Nonogram.prototype.checkColNums = function(col) {
        var num, _i, _len, _ref, _results;
        _ref = this.colNums[col];
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          num = _ref[_i];
          _results.push(num.complete = false);
        }
        return _results;
      };

      return Nonogram;

    })();
    return Nonogram;
  });

  services.factory('Draw', function() {
    return {
      direction: null,
      position: {
        x: null,
        y: null
      },
      startPosition: {
        x: null,
        y: null
      },
      state: false
    };
  });

}).call(this);
